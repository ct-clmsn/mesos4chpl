/**
 * Licensed to the Apache Software Foundation (ASF) under one
 * or more contributor license agreements.  See the NOTICE file
 * distributed with this work for additional information
 * regarding copyright ownership.  The ASF licenses this file
 * to you under the Apache License, Version 2.0 (the
 * "License"); you may not use this file except in compliance
 * with the License.  You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */

/*
 * ChapelScheduler.hpp
 *
 * A mesos-scheduler for Chapel programs!
 *
 * ct.clmsn at gmail dot com 
 * 24AUG2015
 *
 */

#ifndef __MESOS_FRAMEWORK_CHPL_SCHEDULER__
#define __MESOS_FRAMEWORK_CHPL_SCHEDULER__ 1

#include <stdlib.h>

#include <string>
#include <vector>
#include <map>
#include <iostream>

#include <mesos/resources.hpp>
#include <mesos/scheduler.hpp>

using namespace std;
using namespace mesos;

using mesos::Resources;

class ChapelScheduler : public Scheduler {

private:

   // coresReq, processing unit precent required - precent of nodes in a mesos offer current has available
   // memReq, RAM required to run the program
   // cpusReq, number of cores to limit thread processing, if -1, then use *all* threads available
   //
   const double coresReq;
   const int cpusReq, numAttempts;
   const uint64_t memReq;

   const string numLocalesReq, mesosReq, leaderHostname, exec, remoteCmd, user_id;
   size_t tasksLaunched, tasksFinished, tasksFailed, frameworkMessagesReceived;

   bool taskExecError;
   map<string, TaskInfo> launchedTsks;
   CommandInfo chplCmdInfo;

public:

   ChapelScheduler(const int cpus_req, 
                   const uint64_t mem_req, 
                   const double cores_req, 
                   const string& leader_hostname, 
                   const string& executable, 
                   const string& remote_cmd, 
                   const string& usr, 
                   const int num_attempts=10);

   // added function to terminate all active tasks being tracked by this scheduler
   void terminateAllTAsks(SchedulerDriver* driver);

   /*
    * Invoked when the scheduler successfully registers with a Mesos
    * master. A unique ID (generated by the master) used for
    * distinguishing this framework from others and MasterInfo
    * with the ip and port of the current master are provided as arguments.
    */
   void registered(SchedulerDriver* driver, 
                   const FrameworkID& frameworkId, 
                   const MasterInfo& masterInfo);

   /*
    * Invoked when the scheduler re-registers with a newly elected Mesos master.
    * This is only called when the scheduler has previously been registered.
    * MasterInfo containing the updated information about the elected master
    * is provided as an argument.
    */
   void reregistered(SchedulerDriver* driver, 
                     const MasterInfo& masterInfo);

   /*
    * Invoked when the scheduler becomes "disconnected" from the master
    * (e.g., the master fails and another is taking over).
    */
   void disconnected(SchedulerDriver* driver);

   /*
    * Invoked when resources have been offered to this framework. A
    * single offer will only contain resources from a single slave.
    * Resources associated with an offer will not be re-offered to
    * _this_ framework until either (a) this framework has rejected
    * those resources (see SchedulerDriver::launchTasks) or (b) those
    * resources have been rescinded (see Scheduler::offerRescinded).
    * Note that resources may be concurrently offered to more than one
    * framework at a time (depending on the allocator being used). In
    * that case, the first framework to launch tasks using those
    * resources will be able to use them while the other frameworks
    * will have those resources rescinded (or if a framework has
    * already launched tasks with those resources then those tasks will
    * fail with a TASK_LOST status and a message saying as much).
    */
   void resourceOffers(SchedulerDriver* driver, 
                       const vector<Offer>& offers);

   /*
    * Invoked when an offer is no longer valid (e.g., the slave was
    * lost or another framework used resources in the offer). If for
    * whatever reason an offer is never rescinded (e.g., dropped
    * message, failing over framework, etc.), a framework that attempts
    * to launch tasks using an invalid offer will receive TASK_LOST
    * status updats for those tasks (see Scheduler::resourceOffers).
    */
   void offerRescinded(SchedulerDriver* driver, 
                       const OfferID& offerId);

   /*
    * Invoked when the status of a task has changed (e.g., a slave is
    * lost and so the task is lost, a task finishes and an executor
    * sends a status update saying so, etc). If implicit
    * acknowledgements are being used, then returning from this
    * callback _acknowledges_ receipt of this status update! If for
    * whatever reason the scheduler aborts during this callback (or
    * the process exits) another status update will be delivered (note,
    * however, that this is currently not true if the slave sending the
    * status update is lost/fails during that time). If explicit
    * acknowledgements are in use, the scheduler must acknowledge this
    * status on the driver.
    */
   void statusUpdate(SchedulerDriver* driver, 
                     const TaskStatus& status);


   /*
    * Invoked when an executor sends a message. These messages are best
    * effort; do not expect a framework message to be retransmitted in
    * any reliable fashion.
    */
   void frameworkMessage(SchedulerDriver* driver, 
                         const ExecutorID& executorId, 
                         const SlaveID& slaveId, 
                         const string& data);

   /*
    * Invoked when a slave has been determined unreachable (e.g.,
    * machine failure, network partition). Most frameworks will need to
    * reschedule any tasks launched on this slave on a new slave.
    */
   void slaveLost(SchedulerDriver* driver, 
                  const SlaveID& slaveId);


   /*
    * Invoked when an executor has exited/terminated. Note that any
    * tasks running will have TASK_LOST status updates automagically
    * generated.
    */
   void executorLost(SchedulerDriver* driver, 
                     const ExecutorID& executorId, 
                     const SlaveID& slaveId, 
                     int status);

   /*
    * Invoked when there is an unrecoverable error in the scheduler or
    * scheduler driver. The driver will be aborted BEFORE invoking this
    * callback.
    */
   void error(SchedulerDriver* driver, 
              const string& message);

};

#endif

